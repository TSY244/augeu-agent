// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LoginEvent login event
//
// swagger:model LoginEvent
type LoginEvent struct {

	// 事件ID，4624表示成功登录
	// Required: true
	EventID *int64 `json:"EventID"`

	// 事件时间，格式：2006-01-02 15:04:05（注意原数据日期时间连写问题）
	// Required: true
	// Format: date-time
	EventTime *strfmt.DateTime `json:"EventTime"`

	// 登录类型（Unknown表示无法识别的类型）
	// Required: true
	LoginType *string `json:"LoginType"`

	// 设备唯一标识符（UUID格式）
	// Required: true
	MachineUUID *string `json:"MachineUUID"`

	// 触发登录的进程名（-表示无）
	// Required: true
	ProcessName *string `json:"ProcessName"`

	// 源IP地址（-表示无）
	// Required: true
	SourceIP *string `json:"SourceIP"`

	// 登录用户所属域（-表示无）
	// Required: true
	SubjectDomain *string `json:"SubjectDomain"`

	// 登录会话用户（-表示无）
	// Required: true
	SubjectUser *string `json:"SubjectUser"`

	// 登录用户名（SYSTEM表示系统账户）
	// Required: true
	Username *string `json:"Username"`
}

// Validate validates this login event
func (m *LoginEvent) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEventID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEventTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoginType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMachineUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceIP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubjectDomain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubjectUser(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsername(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LoginEvent) validateEventID(formats strfmt.Registry) error {

	if err := validate.Required("EventID", "body", m.EventID); err != nil {
		return err
	}

	return nil
}

func (m *LoginEvent) validateEventTime(formats strfmt.Registry) error {

	if err := validate.Required("EventTime", "body", m.EventTime); err != nil {
		return err
	}

	if err := validate.FormatOf("EventTime", "body", "date-time", m.EventTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *LoginEvent) validateLoginType(formats strfmt.Registry) error {

	if err := validate.Required("LoginType", "body", m.LoginType); err != nil {
		return err
	}

	return nil
}

func (m *LoginEvent) validateMachineUUID(formats strfmt.Registry) error {

	if err := validate.Required("MachineUUID", "body", m.MachineUUID); err != nil {
		return err
	}

	return nil
}

func (m *LoginEvent) validateProcessName(formats strfmt.Registry) error {

	if err := validate.Required("ProcessName", "body", m.ProcessName); err != nil {
		return err
	}

	return nil
}

func (m *LoginEvent) validateSourceIP(formats strfmt.Registry) error {

	if err := validate.Required("SourceIP", "body", m.SourceIP); err != nil {
		return err
	}

	return nil
}

func (m *LoginEvent) validateSubjectDomain(formats strfmt.Registry) error {

	if err := validate.Required("SubjectDomain", "body", m.SubjectDomain); err != nil {
		return err
	}

	return nil
}

func (m *LoginEvent) validateSubjectUser(formats strfmt.Registry) error {

	if err := validate.Required("SubjectUser", "body", m.SubjectUser); err != nil {
		return err
	}

	return nil
}

func (m *LoginEvent) validateUsername(formats strfmt.Registry) error {

	if err := validate.Required("Username", "body", m.Username); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this login event based on context it is used
func (m *LoginEvent) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LoginEvent) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LoginEvent) UnmarshalBinary(b []byte) error {
	var res LoginEvent
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
